\section{Attacks and Counter Measures}

There are many attacks that hackers are able to do. We give a listing of possible attacks and some counter measures if possible:

\begin{description}
  \item[DoS] The attacker attempts to take the server down by creating a lot of traffic that requires a lot of computations by the server. To counteract this, we made our implementation such that the server attempts to delay computationally intensive tasks (i.e.\ generate $K_S$) before the user has been identified. This is why the computation of $K_S$ is only done after reception of the response by the user in \cref{AsymKeyExchange}. This prevents spoofed IP DoS attacks. However, it does not protect against botnet attacks and other kinds of distributed attacks (DDoS) where the user is able to respond.
  \item[DDoS] This attack is among the hardest to prevent. To try and take countermeasures, we can make use of a scalable cloud (e.g.\ Amazon CloudWatch) that automatically allocates more servers if required to keep the application running. We should also use traffic analysis and block access if traffic originates from a suspicious source.
  \item[Replay] The attacker can also resend a message that came from another (valid) party. This way the attacker hopes to open and start a car after it is used by another user. Our solution to this attack is to send a newly generated nonce in every secure symmetric channel set-up. This way the server knows when the message was replayed. Also when billing is done, a timestamp is added to protect against replay attacks. Resending messages that were sent from within the encrypted AES channel is also not possible since we use GCM and the counter is randomly initiated when the connection is set up.
  \item[Eavesdropping] The hacker can also be passive and listen in on the communications channel, but because of symmetric encryption, the attacker can not retrieve the actual message content since he does not posses the key $K_S$.
  \item[Man-in-the-middle attack] In a man-in-the-middle attack, the attacker can break the security by impersonating someone else. After set-up of the encrypted channel (\cref{AsymKeyExchange}), a man-in-the-middle attack is still possible. An intruder $T$ is able to replace the plain text messages with his own public keys and nonce value. Following the \cref{AsymKeyExchange}, an authentication step is always performed: \cref{AuthStep} or \cref{ReauthStep}. After identification, a man-in-the-middle attack can be detected. It is important to note that the user only sends his UVC after the server has been authenticated. Otherwise, an attacker might obtain the certificate and try to impersonate the user. \\
  \textbf{Update June 12, 2016} Not all man-in-the-middle attack types have been averted. Suppose an intruder sets up a connection with both user and server at the same time. During authentication he can then forward the different requests to make it seem authentication was successful. A possible solution to this attack is the following: instead of using ephemeral ECDH, we can use a partially authenticated variant. The server can use a fixed key pair with a public key that is embedded in the smartphone application. The key can still be sent (as it is done in the current implementation), but only as a means of verification. The embedded key should always be used to compute the session key by the user. The user's key remains randomly chosen, ensuring a unique key per session. The same is done when connection to the car. The user is already aware of the public key through the public key certificate provided when a COC is obtained. The usage of these predefined keys averts the man-in-the-middle attack that was previously described.
  \item[Data manipulation] The attacker can change the bits in a coded message. We have counteracted this by introducing message authentication functions (GCM) in our symmetrically encrypted channel. Plain-text messages that must not be manipulated are signed (with EdDSA).
  \item[Data-analysis] The hacker can analyse the data by observing and saving all messages, as to guess the key or the type of messages exchanged (e.g.\ was a COC obtained?). An obvious counter measure is frequently changing the keys of every party. For example public and private keys in \cref{AsymKeyExchange} are always freshly generated resulting in a new key $K_S$ every time a new connection is set up. Random data can also be inserted in the channel to prevent data size analysis.
\end{description}

The remaining attack is mainly a DDoS attack since it is very hard to design a system that is invulnerable to this type of attack. The actual implementation might also be a problem, since bugs can (and will) be present in the software that might result in security risks (buffer overflows come immediately to mind). Finally, no specific measures are taken against data-analysis attacks.

We assumed that the user keeps his COC and private key $d_A^P$ confidential. A security risk occurs otherwise. Sharing of the COC and $d_A^P$ might not be intentional, but by means of a platform specific exploit that breaks sandboxing between applications running on the smartphone. A malicious application might try to obtain this confidential information this way.
